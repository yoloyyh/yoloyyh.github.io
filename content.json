[{"title":"两数相加","date":"2020-03-12T03:12:35.000Z","path":"2020/03/12/两数相加/","text":"题目描述： 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 可以假设除了数字 0 之外，这两个数都不会以 0 开头。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路： 将两个链表看成相同长度进行遍历，短的链表在前面用0补齐； 代码： 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *pre=new ListNode(0); //预设哑结点，方便最后返回头结点 ListNode *cur=pre; int carry=0; while(l1||l2) &#123; int x=(l1!=NULL)? l1-&gt;val:0; //长度不够用0补齐 int y=(l2!=NULL)? l2-&gt;val:0; int sum=x+y+carry; carry=sum/10; //更新进位 sum%=10; cur-&gt;next = new ListNode(sum); cur=cur-&gt;next; if(l1) l1=l1-&gt;next; if(l2) l2=l2-&gt;next; &#125; if(carry) //最后两位数相加产生进位 cur-&gt;next=new ListNode(carry); //则新建一个结点插入 return pre-&gt;next; &#125;&#125;;","link":"","tags":[{"name":"oj刷题","slug":"oj刷题","permalink":"tags/oj刷题/"}]},{"title":"自律使我自由","date":"2020-03-10T12:57:59.000Z","path":"2020/03/10/自律使我自由/","text":"《少有人走的路》中开篇就提到了一个观点：人生是充满苦难的。 明白了这个前提，再遇到困难或者痛苦的事，我们就不会再抱怨为什么坏事都发生在自己头上，我们就会少些逃避，转而去积极的解决问题。 如果人生就是一个又一个不断的麻烦与痛苦，那我们为什么还要继续活下去呢？因为希望，活下去就有希望，纵观整个人生，每个人都逃不过生老病死，但只要你想，活着的过程却可以有趣又生动，甚至对于有些人来说，不断挑战并解决麻烦，正是他们的生存意义所在。 那们我们又该怎么解决人生中的麻烦，获得自由呢？书中提到，只有自律才能解决问题，并且不是一时的自律，而是一直自律。 曾经我以为的自律就是坚持，制定自己的计划，持之以恒的完成就是自律，这本书对自律的解释却令我眼前一亮。 所谓自律，是以积极主动的态度去解决人生中的问题，主要包括四个方面：推迟满足感，承担责任，尊重事实，保持平衡。 推迟满足感，就是我们常说的吃苦在前，享乐在后。举个简单的例子，孩子们经常被要求先写完作业，才能看电视或者玩游戏。如果从小就养成了这种习惯，长大后会更加积极主动的解决问题。很多人明白这样做的好处，却缺少这种能力，对于孩子来说，养成这种习惯最离不开的就是家庭教育，在充满爱与陪伴的家庭里长大的孩子，因为父母的耐心教导，自己面对问题也会更加耐心。对于成年人的我们来说，只能自己改变，强迫自己先解决问题，再享受，从而养成习惯。 不管你是否做到推迟满足感，承担责任都是必须的，一味的逃避问题，问题就会像大山一样横亘在你人生的道路上。责任感出现问题，通常会导致两种人格问题：神经官能症和人格失调；神经官能症患者为自己强加责任，人格失调者却不愿意承担责任。作者提出几乎每个人都有不同程度的神经官能症或者人格失调症，最好的办法就是就诊。人生一世，判断评估自己的角色，了解我们该为何人、何事负责，既是我们的责任，也是无法逃避的问题。 尊重事实，是自律的第三种原则。尊重事实，意味着如实看待现实，杜绝虚假，因为虚假与事实完全对立。我们越是了解事实，处理问题就越是得心应手；对现实了解得越少，思维就越是混乱。虚假、错觉和幻觉，只能让我们不知所措。我们对现实的观念就像是一张地图，凭借这张地图，我们同人生的地形、地貌不断协调和谈判。地图准确无误，我们就能确定自己的位置，知道要到什么地方，怎样到达那里；地图漏洞百出，我们就会迷失方向。 保持平衡，代表着富有弹性的约束机制。我们必须要承担应该的责任，同时也要拒绝承担额外的责任。就像有时候生气也是必要的反击方式。为了保持平衡我们常常需要放弃很多东西，这样才能腾出空间，来接纳新的想法与问题。","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"tags/随笔/"}]},{"title":"深信服在线笔试题回顾","date":"2020-02-26T09:01:50.000Z","path":"2020/02/26/深信服在线笔试题回顾/","text":"题型分值： 1.不定向选择17分：其中可能多选，错选不得分，少选得三分之一分； 2.填空题18分：其中还涉及了概率题； 3.三道编程题65分。 不定向选择： 个人觉得考察范围还是比较广泛的，第一题考察栈的特性，告诉你入队序列，选择可能的出队序列；还有一题考察二叉树的遍历，给出前序遍历序列，选择可能的中序遍历序列；给出几种排序：快排，归并，堆排序等，问题是在不影响原本的时间复杂度的条件上，哪种排序算法能够给双循环链表排序； 以及给你5分钟内有车经过的概率，求15分钟都没有车经过的概率。 还有之前网上看到的关于sizeof()用法的，以及指针与取地址是数据的变化，由于本人现在还算菜鸟，就不给出自己的答案了。 填空题： 之前有上网简单看了一下，我也遇到了三门问题； 一个3*4的方格，从A点到B点可走的路径总数； 还有一个题目涉及图的遍历，由于不能跳出答题界面，我就纯手算的。 编程题： 编程题虽然只有三道，但却占了大部分的分数，所以大家答题时，一定要注意把握好时间，我是最后答的编程题，最后剩余了80分钟。 1.第一题是武汉物资分配问题给你捐赠的物资与数量，在给你各医院需要的物资与数量，每种物资按照所有医院需要的比例进行分配，如果还有剩余就全部分给最后一个医院； 这一题我花费了将近半个小时，定义了结构体做的，由于敲代码实在太菜，而且这个最长的寒假在家吃喝玩乐，敲起来很是费劲。 2.第二题是字符串序列按空格分割，并且每输出一个字符串后面要给一个,结尾不用， 3.第三题是跟你一串后序表达式，输出中序表达式，但是为了确保优先级，需要使用小括号，这个用栈实现即可，可惜我没来得及完成。 不论结果如何，这是我的第一次笔试经历，希望越来越好吧！也希望每个人都能找到工作，2020虽然开头就很难，但我们一定会过去的。","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"tags/随笔/"},{"name":"笔试","slug":"笔试","permalink":"tags/笔试/"}]},{"title":"回文质数","date":"2020-02-18T06:50:58.000Z","path":"2020/02/18/回文质数/","text":"回文描述：写一个程序来找出范围[a,b]，其中5&lt;= a &lt; b &lt;= 100,000间的所有回文质数 。 输入说明：仅 1 行: 二个整数 a 和 b(5&lt;= a &lt; b &lt;= 100,000)。 输出说明：输出一个回文质数的列表，一行一个，每行首尾无空格，最后无空行。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;bool isPrime(int val)&#123; //判断是否为质数 int q; for(q=2;q&lt;=sqrt(val);q++)&#123; if(val%q==0)&#123; return false; &#125; &#125; return true;&#125;bool isSyS(int val)&#123; //判断是否为回文数 int i=0; int reverseVal=0; int valrecord=val; while(valrecord&gt;=1)&#123; reverseVal=reverseVal*10+valrecord%10; valrecord=valrecord/10; &#125; if(reverseVal==val)&#123; //回文数左右对称 return true; &#125;else&#123; return false; &#125;&#125;int main()&#123; int a, b; cin&gt;&gt;a&gt;&gt;b; int i; for(i=a;i&lt;b;i++)&#123; if(isSyS(i)&amp;&amp;isPrime(i))&#123; cout&lt;&lt;i&lt;&lt;endl; &#125; &#125;&#125; ps：需要注意的是本题这种解法，时间复杂度是很高的，由于a,b的值不是特别大，才没有超时，如果a, b的值限定的比较大，还要继续优化。 根据查询素数性质发现，4位、6位、8位的回文数都不是素数 ，2位数的只有三个回文数，其余可以按照不同的位数分别处理。","link":"","tags":[{"name":"oj刷题","slug":"oj刷题","permalink":"tags/oj刷题/"},{"name":"回文数字","slug":"回文数字","permalink":"tags/回文数字/"}]},{"title":"数字串处理","date":"2020-02-16T10:40:54.000Z","path":"2020/02/16/数字串处理/","text":"问题描述：给你一串数字，找出在这串数字中连续出现次数最多的那个数字；若有多个数字连续出现的次数相当，则找出第一次出现该次数的那个数字。 输入说明：每组测试数据有2行，测试数据的第一行有1个整数n（1&lt;n&lt;100），表示数字串中有几个数；测试数据的第二行有n个数，数字串中的数字k，k（1 ≤k ≤100），每个数字之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。 输出说明：对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为两个整数：出现次数最多的那整数，以及它的出现次数。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243include &lt;iostream&gt;using namespace std;int main() &#123; int n,ma; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int a[n],m[105]; int i; for(i=0;i&lt;105;i++) &#123; m[i]=0; &#125; for(i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; m[a[0]]=1; for(i=0;i&lt;n-1;i++) &#123; if(a[i]==a[i+1]) &#123; m[a[i]]++; &#125; else m[a[i+1]]=1; &#125; ma=0; for(i=1;i&lt;105;i++) &#123; if(m[i]&gt;m[ma]) ma=i; &#125; int mi,j,k; for(i=ma+1;i&lt;105;i++) &#123; if(m[i]==m[ma]) &#123; //如果两个不同的数连续出现次数相同 for(j=0;j&lt;n;j++) &#123; if(a[j]==ma) //找到先输入的数 mi=j; if(a[j]==i) k=j; &#125; if(mi&gt;k) ma=a[k]; &#125; &#125; printf(\"%d %d\\n\",ma,m[ma]); &#125; return 0;&#125;","link":"","tags":[{"name":"oj刷题","slug":"oj刷题","permalink":"tags/oj刷题/"},{"name":"循环","slug":"循环","permalink":"tags/循环/"}]},{"title":"求阶乘最后的非0位","date":"2020-02-14T06:43:41.000Z","path":"2020/02/14/求阶乘最后的非0位/","text":"问题描述：输入一个不大于1000的整数N，输出N!最后的非0位； 思路：由于N！可能溢出，所以每次都通过取余要N！后五位数，如果末尾为0，则进行循环，令结果除以10，最后输出结果对10取余，即可得到最后一位非0数。 12345678910111213141516171819#include&lt;cstdio&gt;int main()&#123; int n,i; long long s; while(scanf(\"%d\",&amp;n)!=EOF) &#123; s=1; for(i=2;i&lt;=n;i++) &#123; s*=i; while(s%10==0) s/=10; s=s%100000; &#125; printf(\"%lld\\n\",s%10); &#125; return 0;&#125;","link":"","tags":[{"name":"oj刷题","slug":"oj刷题","permalink":"tags/oj刷题/"}]},{"title":"求n的阶乘末尾0的个数","date":"2020-01-29T02:20:55.000Z","path":"2020/01/29/我的第一篇博客文章/","text":"问题描述：输入整数n，输出n!末尾0的个数； 思路：n！= 123…n；首先要思考一下0是怎么来的，0是2*5得来的，那也就是说看有多少个2,5就可以了，再分析，因子2出现的次数，2,4,6,8…，因子5出现的次数，5,10,15,25… 很显然，2出现的次数一定是比5出现的次数多的，那么我们只需要计算5出现的次数有多少，就可以得到会有多少个10，也就是会有多少个0了。所以思路就是，遍历1-n，求每个数中因子5的个数，累加起来就是n!末尾0的个数。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int main() &#123; int i,j; int n; while(scanf(\"%d\",&amp;n)!=EOF) &#123; int s=0; while(n) &#123; n=n/5; //n除以5得到的是1~n中包含有一个因子5的个数 s+=n; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125; ps：需要注意的是，由于1-n中可能有的数可以被5整除好几次，所以必须将这个数再除以5，得到1-n中包含有两个因子5的个数，依次循环进行累加才可得到全部5的因子个数。","link":"","tags":[{"name":"oj刷题","slug":"oj刷题","permalink":"tags/oj刷题/"}]},{"title":"Hello World","date":"2020-01-28T09:41:50.181Z","path":"2020/01/28/hello-world/","text":"Hello World！ 这句话应该是大多数程序员们敲下的第一行代码，代表着程序员们向编程世界的探索之旅启程了。 这让我同样想到了《老友记》第一集中Monica对Rachel说的一句话：Welcome to the real word! It sucks , but you are gonna love it. 这也是我想对每个朋友说的一句话。","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"tags/随笔/"}]}]